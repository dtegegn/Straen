// Created by Michael Simms on 9/5/12.
// Copyright (c) 2012 Michael J. Simms. All rights reserved.

// This Source Code Form is subject to the terms of the Mozilla Public
// License, v. 2.0. If a copy of the MPL was not distributed with this
// file, You can obtain one at http://mozilla.org/MPL/2.0/.

#include "LiftingActivity.h"
#include "ActivityAttribute.h"
#include "Defines.h"
#include "UnitMgr.h"

LiftingActivity::LiftingActivity(GForceAnalyzer* const analyzer)
	:  m_analyzer(analyzer), Activity()
{
	m_repsCorrected = 0;
	m_sets = 0;
	m_lastRepTime = 0;
	m_restingTimeMs = 0;
}

LiftingActivity::~LiftingActivity()
{
	m_computedRepList.clear();
}

std::string LiftingActivity::GetSocialNetworkStartingPostStr() const
{
	std::string name = GetType();
	std::transform(name.begin(), name.end(), name.begin(), tolower);
	
	std::ostringstream str;
	std::string timeStr = FormatTimeOfDayStr(GetStartTimeSecs());
	str << "Doing some " << name << " at " << timeStr << " (Tweet auto-generated by " APP_NAME ")!";
	return str.str();
}

std::string LiftingActivity::GetSocialNetworkStoppingPostStr() const
{
	std::string name = GetType();
	std::transform(name.begin(), name.end(), name.begin(), tolower);
	
	std::ostringstream str;
	std::string timeStr = FormatTimeStr(ElapsedTimeInSeconds());
	str << "Did " << name << " at " << timeStr << " (Tweet auto-generated by " APP_NAME ")!";
	return str.str();
}

void LiftingActivity::SetGForceAnalyzer(GForceAnalyzer* const analyzer)
{
	if (analyzer)
	{
		m_analyzer = analyzer;
	}
}

void LiftingActivity::ListUsableSensors(std::vector<SensorType>& sensorTypes) const
{
	sensorTypes.push_back(SENSOR_TYPE_ACCELEROMETER);
}

bool LiftingActivity::ProcessAccelerometerReading(const SensorReading& reading)
{
	try
	{
		if (m_analyzer)
		{
			GraphPeakList dataPeaks = m_analyzer->ProcessAccelerometerReading(reading);
			GraphPeakList::iterator dataPeaksIter = dataPeaks.begin();
			while (dataPeaksIter != dataPeaks.end())
			{
				GraphPeak& curPeak = (*dataPeaksIter);
				m_computedRepList.push_back(curPeak);

				uint64_t elapsedTime = reading.time - m_lastRepTime;
				if (elapsedTime > 1000)
				{
					if (m_lastRepTime > 0)
					{
						m_restingTimeMs += elapsedTime;
					}
					if (elapsedTime > 100000)
					{
						++m_sets;
					}
				}

				m_lastRepTime = reading.time;
				++dataPeaksIter;
			}
		}
	}
	catch (...)
	{
	}

	return Activity::ProcessAccelerometerReading(reading);
}

ActivityAttributeType LiftingActivity::QueryActivityAttribute(const std::string& attributeName) const
{
	ActivityAttributeType result;

	result.startTime = 0;
	result.endTime = 0;
	result.unitSystem = UnitMgr::GetUnitSystem();

	if (attributeName.compare(ACTIVITY_ATTRIBUTE_REPS) == 0)
	{
		result.value.intVal = Total();
		result.valueType = TYPE_INTEGER;
		result.measureType = MEASURE_COUNT;
		result.valid = result.value.intVal > 0;
	}
	else if (attributeName.compare(ACTIVITY_ATTRIBUTE_REPS_COMPUTED) == 0)
	{
		result.value.intVal = ComputedTotal();
		result.valueType = TYPE_INTEGER;
		result.measureType = MEASURE_COUNT;
		result.valid = result.value.intVal > 0;
	}
	else if (attributeName.compare(ACTIVITY_ATTRIBUTE_REPS_CORRECTED) == 0)
	{
		result.value.intVal = CorrectedTotal();
		result.valueType = TYPE_INTEGER;
		result.measureType = MEASURE_COUNT;
		result.valid = result.value.intVal > 0;
	}
	else if (attributeName.compare(ACTIVITY_ATTRIBUTE_CURRENT_PACE) == 0)
	{
		uint16_t total = Total();
		result.value.timeVal = Pace();
		result.valueType = TYPE_TIME;
		result.measureType = MEASURE_TIME;
		result.valid = total > 0;
	}
	else if (attributeName.compare(ACTIVITY_ATTRIBUTE_SETS) == 0)
	{
		uint16_t total = Total();
		result.value.intVal = Sets();
		result.valueType = TYPE_INTEGER;
		result.measureType = MEASURE_COUNT;
		result.valid = total > 0;
	}
	else if (attributeName.find(ACTIVITY_ATTRIBUTE_GRAPH_PEAK) == 0)
	{
		if (m_analyzer)
		{
			const char* numStr = attributeName.c_str() + strlen(ACTIVITY_ATTRIBUTE_GRAPH_PEAK);
			uint16_t num = atol(numStr);
			
			if ((num > 0) && (num <= m_computedRepList.size()))
			{
				GraphPeak peak = m_computedRepList.at(num - 1);
				result.valueType = TYPE_INTEGER;
				result.measureType = MEASURE_INDEX;
				result.value.intVal = peak.peak.index;
				result.valid = true;
			}
			else
			{
				result.valid = false;
			}
		}
		else
		{
			result.valid = false;
		}
	}
	else if (attributeName.find(ACTIVITY_ATTRIBUTE_MEAN_PEAK_AREA) == 0)
	{
		uint16_t total = Total();
		result.value.doubleVal = GetPeakAreaMean();
		result.valueType = TYPE_DOUBLE;
		result.measureType = MEASURE_NOT_SET;
		result.valid = total > 0;
	}
	else if (attributeName.find(ACTIVITY_ATTRIBUTE_STDDEV_PEAK_AREA) == 0)
	{
		uint16_t total = Total();
		result.value.doubleVal = GetPeakAreaStdDev();
		result.valueType = TYPE_DOUBLE;
		result.measureType = MEASURE_NOT_SET;
		result.valid = total > 0;
	}
	else
	{
		result = Activity::QueryActivityAttribute(attributeName);
	}
	return result;
}

void LiftingActivity::SetActivityAttribute(const std::string& attributeName, ActivityAttributeType attributeValue)
{
	if (attributeName.compare(ACTIVITY_ATTRIBUTE_REPS_CORRECTED) == 0)
	{
		m_repsCorrected = attributeValue.value.intVal;
	}

	Activity::SetActivityAttribute(attributeName, attributeValue);
}

uint16_t LiftingActivity::Sets() const
{
	if (m_sets > 0)
		return m_sets;
	if (Total() > 0)
		return 1;
	return 0;
}

time_t LiftingActivity::Pace() const
{
	uint16_t total = Total();
	if (total > 0)
	{
		return ElapsedTimeInSeconds() / total;
	}
	return 0;
}

double LiftingActivity::GetPeakAreaMean() const
{
	double mean = (double)0.0;

	if (m_computedRepList.size() > 0)
	{
		GraphPeakList::const_iterator dataPeaksIter = m_computedRepList.begin();
		while (dataPeaksIter != m_computedRepList.end())
		{
			const GraphPeak& curPeak = (*dataPeaksIter);
			mean += curPeak.area;
			++dataPeaksIter;
		}
		mean /= m_computedRepList.size();
	}
	return mean;
}

double LiftingActivity::GetPeakAreaStdDev() const
{
	double stdDev = (double)0.0;

	if (m_computedRepList.size() > 0)
	{
		double mean = GetPeakAreaMean();

		if (mean > (double)0.01)
		{
			GraphPeakList::const_iterator dataPeaksIter = m_computedRepList.begin();
			while (dataPeaksIter != m_computedRepList.end())
			{
				const GraphPeak& curPeak = (*dataPeaksIter);
				double temp = curPeak.area - mean;
				temp *= temp;
				stdDev += temp;
				++dataPeaksIter;
			}
			stdDev /= m_computedRepList.size();
			stdDev = sqrt(stdDev);
		}
	}
	return stdDev;
}

void LiftingActivity::BuildAttributeList(std::vector<std::string>& attributes) const
{
	attributes.push_back(ACTIVITY_ATTRIBUTE_REPS);
	attributes.push_back(ACTIVITY_ATTRIBUTE_CURRENT_PACE);
	attributes.push_back(ACTIVITY_ATTRIBUTE_SETS);
	attributes.push_back(ACTIVITY_ATTRIBUTE_ADDITIONAL_WEIGHT);
	Activity::BuildAttributeList(attributes);
}

void LiftingActivity::BuildSummaryAttributeList(std::vector<std::string>& attributes) const
{
	attributes.push_back(ACTIVITY_ATTRIBUTE_REPS);
	attributes.push_back(ACTIVITY_ATTRIBUTE_REPS_COMPUTED);
	attributes.push_back(ACTIVITY_ATTRIBUTE_REPS_CORRECTED);
	attributes.push_back(ACTIVITY_ATTRIBUTE_CURRENT_PACE);
	attributes.push_back(ACTIVITY_ATTRIBUTE_SETS);
	attributes.push_back(ACTIVITY_ATTRIBUTE_ADDITIONAL_WEIGHT);
	Activity::BuildSummaryAttributeList(attributes);
}

bool LiftingActivity::CheckSetsInterval()
{
	if ((m_intervalWorkout.workoutId == INTERVAL_WORKOUT_ID_NOT_SET) ||
		(m_intervalWorkoutState.nextSegmentIndex >= m_intervalWorkout.segments.size()))
	{
		return false;
	}

	const IntervalWorkoutSegment& segment = m_intervalWorkout.segments.at(m_intervalWorkoutState.nextSegmentIndex);
	if (segment.units == INTERVAL_UNIT_SETS)
	{
		if (m_sets >= segment.quantity)
		{
			return true;
		}
	}
	return false;
}

bool LiftingActivity::CheckRepsInterval()
{
	if ((m_intervalWorkout.workoutId == INTERVAL_WORKOUT_ID_NOT_SET) ||
		(m_intervalWorkoutState.nextSegmentIndex >= m_intervalWorkout.segments.size()))
	{
		return false;
	}

	const IntervalWorkoutSegment& segment = m_intervalWorkout.segments.at(m_intervalWorkoutState.nextSegmentIndex);
	if (segment.units == INTERVAL_UNIT_REPS)
	{
		uint16_t total = Total();
		if (total >= segment.quantity)
		{
			return true;
		}
	}
	return false;
}

void LiftingActivity::AdvanceIntervalState()
{
	m_intervalWorkoutState.lastSetCount = 0;
	m_intervalWorkoutState.lastRepCount = 0;
	Activity::AdvanceIntervalState();
}

